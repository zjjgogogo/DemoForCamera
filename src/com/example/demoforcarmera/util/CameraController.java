package com.example.demoforcarmera.util;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.util.List;import com.example.demoforcarmera.util.CameraHelper.CameraInfo2;import android.content.Context;import android.graphics.Point;import android.graphics.SurfaceTexture;import android.hardware.Camera;import android.hardware.Camera.Parameters;import android.hardware.Camera.Size;import android.util.Log;import android.view.WindowManager;public class CameraController {	final String TAG = "CameraController";	Context context;	private Camera mCamera;	private CameraHelper mCameraHelper;	private int flash_state = 0;	private int currentCameraId = 0;	private int count = 0;	public CameraController(Context context) {		this.context = context;		mCameraHelper = new CameraHelper(context);		if (mCameraHelper.hasBackCamera()) {			count++;		}		if (mCameraHelper.hasFrontCamera()) {			count++;		}	}	public void changeFlashMode() {		Parameters parameters = mCamera.getParameters();		switch (flash_state) {		case 0:			flash_state = 1;			parameters.setFlashMode(Parameters.FLASH_MODE_ON);			break;		case 1:			flash_state = 2;			parameters.setFlashMode(Parameters.FLASH_MODE_AUTO);			break;		case 2:			flash_state = 0;			parameters.setFlashMode(Parameters.FLASH_MODE_OFF);			break;		}		mCamera.setParameters(parameters);		mCamera.stopPreview();		mCamera.startPreview();	}	protected Size getSize(List<Size> previewSize) {		if (previewSize.size() == 1) {			return previewSize.get(0);		} else {			Point mPoint = new Point();			WindowManager windowManager = (WindowManager) context					.getSystemService(Context.WINDOW_SERVICE);			windowManager.getDefaultDisplay().getSize(mPoint);			int width = (int) (mPoint.x / 1.5);			Size temp = previewSize.get(0);			for (Size size : previewSize) {				temp = size;				Log.e(TAG, "preView Size width:" + size.width + " , height: "						+ size.height);				if (width >= size.width) {					break;				}			}			return temp;		}	}	protected void initCamera() {		mCameraHelper = new CameraHelper(context);		Parameters parameters = mCamera.getParameters();		// TODO adjust by getting supportedPreviewSizes and then choosing		// the best one for screen size (best fill screen)		List<Size> previewSize = parameters.getSupportedPreviewSizes();		Size mSize = getSize(previewSize);		Log.e(TAG, "preView Size width:" + mSize.width + " , height: "				+ mSize.height);		parameters.setPreviewSize(mSize.width, mSize.height);		parameters.setFlashMode(Parameters.FLASH_MODE_OFF);		if (parameters.getSupportedFocusModes().contains(				Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) {			parameters					.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);		}		mCamera.setParameters(parameters);		mCamera.setDisplayOrientation(90);	}	public int getCameraCount() {		return count;	}	public void setupCamera(SurfaceTexture surface) {		mCamera = mCameraHelper.openCamera(currentCameraId);		initCamera();		try {			mCamera.setPreviewTexture(surface);			mCamera.startPreview();		} catch (IOException ioe) {			ioe.printStackTrace();		}	}	public void switchCamera(SurfaceTexture surface) {		mCamera.stopPreview();		mCamera.release();		currentCameraId = (currentCameraId + 1)				% mCameraHelper.getNumberOfCameras();		setupCamera(surface);	}	public void takeByAutoFocus(final String path, final int pictureWidth,			final int pictureHeight) {		mCamera.autoFocus(new Camera.AutoFocusCallback() {			@Override			public void onAutoFocus(boolean success, Camera camera) {				takePicture(path, pictureWidth, pictureHeight);			}		});	}	public CameraInfo2 getCameraInfo() {		CameraInfo2 cameraInfo = new CameraInfo2();		mCameraHelper.getCameraInfo(currentCameraId, cameraInfo);		return cameraInfo;	}	public void takePicture(final String path, int pictureWidth,			int pictureHeight) {		Camera.Parameters params = mCamera.getParameters();		params.setPictureSize(pictureWidth, pictureHeight);		params.setRotation(mCameraHelper.getCameraDisplayOrientation(context,				currentCameraId));		mCamera.setParameters(params);		for (Camera.Size size2 : mCamera.getParameters()				.getSupportedPictureSizes()) {			Log.i(TAG, "Supported: " + size2.width + "x" + size2.height);		}		mCamera.takePicture(null, null, new Camera.PictureCallback() {			@Override			public void onPictureTaken(byte[] data, final Camera camera) {				final File pictureFile = new File(path);				try {					FileOutputStream fos = new FileOutputStream(pictureFile);					fos.write(data);					fos.close();				} catch (FileNotFoundException e) {					Log.d(TAG, "File not found: " + e.getMessage());				} catch (IOException e) {					Log.d(TAG, "Error accessing file: " + e.getMessage());				}			}		});	}	public void closeCamera() {		if (mCamera != null) {			mCamera.stopPreview();			mCamera.release();		}	}}